# 백트래킹

- 백트래킹 기법은 해를 찾는 도중에 *막히면*, 즉, 해가 아니면 되돌아가서 다시 해를 찾아가는 기법이다.
- 백트래킹 기법은 `최적화(optimization)`문제와 `결정(decision)`문제를 해결할 수 있다.

💡 `결정 문제` : 문제의 조건을 만족하는 해가 존재하는 지의 여부를 *yes* 또는 *no*로 답하는 문제.

- 미로 찾기
    - 입구와 출구가 주어진 미로에서 입구부터 출구까지의 경로를 찾는 문제
    - 스택을 이용하여 지나온 경로를 역으로 짚어 되돌아 간다.
- n-Queen 문제
- Map coloring
- 부분집합의 합(Subset Sum) 문제 등

## 백트래킹 기법

- 어떤 노드의 유망성을 점검한 후에 유망(promising)하지 않다고 결정되면 그 노드의 부모로 되돌아가(backtracking) 다음 자식 노드로 간다.
- 어떤 노드를 방문하였을 때 그 노드를 포함한 경로가 해답이 될 수 없으면 그 노드는 유망하지 않다고 하며, 반대로 해답의 가능성이 있으면 유망하다고 한다.
- 가지치기(prunning) : 유망하지 않는 노드가 포함되는 경로는 더 이상 고려하지 않는다.

### 백트래킹과 깊이우선탐색과의 차이

- 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면, 더 이상 그 경로를 따라가지 않음로써 시도의 횟수를 줄인다 : `가지치기(Prunning)`
    - 깊이우선탐색이 모든 경로를 추적하는 데 비해 백트래킹은 불필요한 경로를 조기에 차단한다.
    - 깊이우선탐색을 가하기에는 경우의 수가 너무나도 많은 문제, 즉 *N!가지의 경우의 수를 가진 문제*에 대해 적용할 수 있다.
- 백트래킹 알고리즘을 적용하면 일반적으로 경우의 수가 줄어들지만, 이 역시 최악의 경우에는 여전히 지수함수 시간(Exponential Time)을 요하므로 처리 불가능하다.

## 백트래킹 알고리즘의 절차

1. 상태 공간 트리의 깊이 우선 검색을 실시
2. 각 노드가 유망한지 점검
3. 만일 그 노드가 유망하지 않으면, 그 노드의 부모 노드로 돌아가서 검색 재개

### 일반적인 백트래킹 알고리즘

```python
def checknode(v) : #node
    if promising(v) :
        # 재귀 함수의 basic 파트
        if there is a solution at v :
            write the solution
        # 재귀 함 수의 유도 파트
        else :
            for u in each child of v :
                checknode(u)
```

## 백트래킹 예제 : 부분집합

> {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}의 powerset 중 원소의 합이 10인 부분집합을 구하시오.

### 부분집합 구하기

- 어떤 집합의 공집합과 자기자신을 포함한 모든 부분집합을 `powerset`이라고 하며, 구하고자 하는 어떤 집합의 원소 개수가 n일 경우 부분집합의 개수는 2^n개이다.
- 백트래킹 기법으로 powerset을 구할 수 있다.
    - 일반적인 백트래킹 접근 방법을 이용한다.
    - n개의 원소가 들어있는 집합의 2^n개의 부분집합을 만들 때는, true 혹은 false 값을 가지는 항목들로 구성된 n개의 배열을 만드는 방법으로 접근할 수 있다.
        - 이 때 배열의 i번째 항목은 i번째 원소가 부분집합의 값인지 아닌지를 나타내는 값이다.

### `재귀 호출`을 이용한 부분집합 생성 알고리즘

```python
# n개의 원소를 대상으로 하며, 현재의 depth가 k인 경우
def powerset(n, k):

		# basic part, n번째 요소까지를 모두 결정했으므로 부분집합을 출력한다.
    if n == k:
        for i in range(n):
            # A의 i번째 요소가 true, 즉 1일 경우에만 arr의 i번째 요소에 해당하는 값을 포함하여 print 한다.
            if A[i] :
                print(arr[i], end=" ")

    # inductive part, k번 요소의 포함 여부를 결정하고 다음 번 요소로 넘어간다.
    else:
        # k번째 요소를 부분집합에 포함시키는 경우
        A[k] = 1
        powerset(n, k+1)
        # k번째 요소를 부분집합에 포함시키지 않는 경우
        A[k] = 0
        powerset(n, k+1)
        
powerset(N, 0)
```

### 💡비교 : loop를 이용하여 부분집합을 생성하고 출력하는 방법

```python
bit = [0, 0, 0, 0]
for i in range(2):
    bit[0] = i
    for j in range(2):
        bit[1] = j
        for k in range(2):
            bit[2] = k
            for l in range(2):
                bit[3] = l
                print(bit)
```

### 원소의 합이 10이 넘어가는 경우 가지치기하기

```python
def powerset(n, k, cursum):
    if cursum > 10:
        return
    if n == k:
        for i in range(n):
            if A[i] :
                print(arr[i], end=" ")
    else:
        # k번째 요소를 부분집합에 포함시키는 경우 합의 값에 k번째 요소 더해주기
        A[k] = 1
        powerset(n, k+1, cursum + arr[k])
        # k번째 요소를 부분집합에 포함시키지 않는 경우는 기존 값 넘겨주기
        A[k] = 0
        powerset(n, k+1, cursum)
```
--------
ⓒ 2021. `chloeelog` all rights reserved.
